rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isLoggedIn() {
      return request.auth != null;
    }

    function userIsAdmin() {
      let user = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return user != null && user.data.is_admin == true;
    }

    function userIsPlayer(lobby) {
      return exists(/databases/$(database)/documents/lobbies/$(lobby)/players/$(request.auth.uid));
    }
    // Allows only "players", not "spectators".
    function userIsActivePlayer(lobby) {
      return userIsPlayer(lobby) && get(/databases/$(database)/documents/lobbies/$(lobby)/players/$(request.auth.uid)).data.role == "player";
    }
    function userIsCreator(lobby) {
      return get(/databases/$(database)/documents/lobbies/$(lobby)).data.creator_uid == request.auth.uid;
    }
    function userIsInLobby(lobby) {
      return userIsPlayer(lobby) || userIsCreator(lobby);
    }
    function userIsJudge(lobby, turn) {
      return get(/databases/$(database)/documents/lobbies/$(lobby)/turns/$(turn)).data.judge_uid == request.auth.uid;
    }
    // Checks that the user actually has the cards they want to submit.
    function userHasCards(lobby, turn) {
      // Can't iterate arrays, so will only check the first card:
      let card = request.resource.data.cards[0];
      // TODO: users could potentially hack their 2nd & 3rd card, lol.
      return exists(/databases/$(database)/documents/lobbies/$(lobby)/turns/$(turn)/player_data/$(request.auth.uid)/hand/$(card.id));
    }
    function isCardContentUnmodified(lobby, turn, userID, cardID) {
      let card = get(/databases/$(database)/documents/lobbies/$(lobby)/turns/$(turn)/player_data/$(userID)/hand/$(cardID)).data;
      return request.resource.data['content'] == card['content'];
    }

  	match /decks/{document=**} {
    	allow read;
      allow write: if isLoggedIn() && userIsAdmin();
    }
  	match /lobbies/{lobby} {
      // Anyone can read basic lobby data:
    	allow read: if isLoggedIn();
      // Lobby creator can change lobby settings:
      allow update: if isLoggedIn() && userIsCreator(lobby);

      match /{path=**} {
        // But only players can read internal data: turns, players, etc.
        allow read: if isLoggedIn() && (userIsAdmin() || userIsInLobby(lobby));
      }
      
      match /players/{userID} {
        // allow reading and deleting your own info.
        allow read, delete: if isLoggedIn() && request.auth.uid == userID;
      }
      match /deck_prompts/{document=**} {
        allow write: if isLoggedIn() && userIsCreator(lobby);
        // Players can remove prompt cards from deck:
        allow delete: if isLoggedIn() && userIsActivePlayer(lobby);
      }
      match /deck_responses/{document=**} {
        allow write: if isLoggedIn() && userIsCreator(lobby);
      }
      match /turns/{turn} {
        // Judge can update turn data, e.g. prompt:
        allow update: if isLoggedIn() && userIsJudge(lobby, turn);
      }
      match /turns/{turn}/player_responses/{userID} {
        // Allow players to submit once:
        allow create: if isLoggedIn() && request.auth.uid == userID
                      && userIsActivePlayer(lobby) && userHasCards(lobby, turn);
        // Judge can reveal:
        allow update: if isLoggedIn() && userIsJudge(lobby, turn);
      }
      match /turns/{turn}/player_data/{userID}/hand/{cardID} {
        // Allow players to update some fields:
        allow update: if isLoggedIn() && request.auth.uid == userID
                      && isCardContentUnmodified(lobby, turn, userID, cardID);
      }
    }
    match /users/{userID} {
      // allow reading only your own info when you are logged in.
      // also allow deleting your own info:
      allow read, delete: if isLoggedIn() && request.auth.uid == userID;
      allow write: if userIsAdmin();
    }
    match /{document=**} {
      allow read, write: if false;
    }
  }
}